"""
CIP Redline Reviews Page v2.0 - CCE-Plus Integration
Side-by-side clause review workflow for QA/QC of AI-suggested contract revisions.
- CCE-Plus: Workflow gate enforcement (requires risk analysis complete)
- CCE-Plus: Deterministic report generation with audit trail
"""

import streamlit as st
import requests
import json
import re
import os
from datetime import datetime
from typing import Dict, List, Optional
import sys
from pathlib import Path

# Add backend to path
backend_path = Path(__file__).parent.parent.parent / "backend"
sys.path.insert(0, str(backend_path))

from components.page_wrapper import init_page, page_header, content_container

# Import CCE-Plus modules
try:
    from workflow_gates import WorkflowGate
    from report_generator import ReportGenerator
    WORKFLOW_GATES_AVAILABLE = True
except ImportError:
    WORKFLOW_GATES_AVAILABLE = False

# ============================================================================
# CONFIGURATION
# ============================================================================

API_BASE = "http://localhost:5000/api"

SEVERITY_CONFIG = {
    "dealbreaker": {"icon": "ðŸ”´", "color": "#EF4444", "bg": "rgba(239,68,68,0.15)", "label": "DEALBREAKER"},
    "critical": {"icon": "ðŸŸ ", "color": "#F97316", "bg": "rgba(249,115,22,0.15)", "label": "CRITICAL"},
    "important": {"icon": "ðŸŸ¡", "color": "#EAB308", "bg": "rgba(234,179,8,0.15)", "label": "IMPORTANT"},
    "standard": {"icon": "ðŸŸ¢", "color": "#22C55E", "bg": "rgba(34,197,94,0.15)", "label": "STANDARD"},
}

COLORS = {
    "header_bg": "rgba(30, 41, 59, 0.6)",
    "pane_bg": "rgba(30, 41, 59, 0.4)",
    "border": "rgba(255, 255, 255, 0.1)",
    "deletion": "#EF4444",
    "deletion_bg": "rgba(239, 68, 68, 0.1)",
    "addition": "#22C55E",
    "addition_bg": "rgba(34, 197, 94, 0.15)",
    "accent": "#A78BFA",
    "text_primary": "#E2E8F0",
    "text_secondary": "#94A3B8",
}

# ============================================================================
# SESSION STATE
# ============================================================================

def init_redline_state():
    """Initialize session state with defaults."""
    defaults = {
        "rdl_contract_id": None,
        "rdl_contract_title": "",
        "rdl_findings": [],
        "rdl_current_index": 0,
        "rdl_decisions": {},
        "rdl_show_modify_modal": False,
        "rdl_loading": False,
        "rdl_error": None,
        "rdl_source": None,
    }
    for key, value in defaults.items():
        if key not in st.session_state:
            st.session_state[key] = value


# ============================================================================
# API FUNCTIONS
# ============================================================================

def api_get_contracts() -> List[Dict]:
    """GET /api/contracts - return list of contracts."""
    try:
        response = requests.get(f"{API_BASE}/contracts", timeout=10)
        if response.status_code != 200:
            return []
        data = response.json()
        contracts = data if isinstance(data, list) else data.get("contracts", data.get("data", []))
        return [c for c in contracts if c and isinstance(c, dict)]
    except Exception:
        return []


def api_run_analysis(contract_id: int) -> Dict:
    """POST /api/analyze - run fresh analysis."""
    try:
        response = requests.post(
            f"{API_BASE}/analyze",
            json={"contract_id": contract_id},
            timeout=120
        )
        return response.json()
    except Exception as e:
        return {"error": str(e)}


def api_save_redline(contract_id: int, decisions: list, risk_before: str) -> Dict:
    """Save redline decisions to database."""
    try:
        response = requests.post(
            f"{API_BASE}/redline/save",
            json={
                'contract_id': contract_id,
                'decisions': decisions,
                'overall_risk_before': risk_before
            },
            timeout=30
        )
        return response.json()
    except Exception as e:
        return {'error': str(e)}


# ============================================================================
# WORKFLOW GATE & REPORT HELPERS
# ============================================================================

def check_workflow_gate(contract_id: int) -> tuple[bool, str]:
    """
    Check if redline review can be started for this contract.

    Returns:
        (can_proceed: bool, message: str)
    """
    if not WORKFLOW_GATES_AVAILABLE:
        return True, ""  # Graceful degradation

    try:
        db_path = str(backend_path.parent / "data" / "contracts.db")
        gate = WorkflowGate(db_path)
        can_proceed, msg = gate.can_start_redlines(contract_id)
        return can_proceed, msg
    except Exception as e:
        return False, f"Error checking workflow gate: {e}"


def advance_workflow_after_approval(contract_id: int) -> bool:
    """
    Advance workflow after redline approval.
    Marks risk complete and unlocks compare stage.

    Returns:
        True if successful, False otherwise
    """
    if not WORKFLOW_GATES_AVAILABLE:
        return True  # Graceful degradation

    try:
        db_path = str(backend_path.parent / "data" / "contracts.db")
        gate = WorkflowGate(db_path)
        # Mark risk complete and unlock redlines
        success = gate.advance_stage(contract_id, 'risk')
        if success:
            # Redlines approved, unlock compare
            gate.advance_stage(contract_id, 'redline')
            return True
        return False
    except Exception:
        return False


def generate_redline_report(contract_id: int) -> tuple[str, str]:
    """
    Generate deterministic redline report.

    Returns:
        (report_content: str, report_id: str)
    """
    if not WORKFLOW_GATES_AVAILABLE:
        return "Report generation not available (modules not loaded)", "N/A"

    try:
        db_path = str(backend_path.parent / "data" / "contracts.db")
        api_key = os.getenv('ANTHROPIC_API_KEY')

        if not api_key:
            return "Error: ANTHROPIC_API_KEY not set", "N/A"

        generator = ReportGenerator(db_path, api_key)
        report, report_id = generator.generate_redline_report(contract_id)
        return report, report_id
    except Exception as e:
        return f"Error generating report: {e}", "N/A"


# ============================================================================
# DATA LOADING FUNCTIONS
# ============================================================================

def flatten_findings(analysis: Dict) -> List[Dict]:
    """Flatten analysis response into list of findings with severity."""
    findings = []
    severity_map = {
        "dealbreakers": "dealbreaker",
        "critical_items": "critical",
        "important_items": "important",
        "standard_items": "standard"
    }
    for group_key, severity in severity_map.items():
        for item in analysis.get(group_key, []):
            item["severity"] = severity
            findings.append(item)
    return findings


def load_findings_from_risk_analysis() -> List[Dict]:
    """Load from st.session_state['risk_findings'] if available."""
    risk_findings = st.session_state.get("risk_findings", [])
    if not risk_findings:
        return []
    # Ensure severity is set
    for f in risk_findings:
        if "severity" not in f:
            risk_level = f.get("risk_level", "STANDARD").upper()
            severity_map = {
                "DEALBREAKER": "dealbreaker",
                "CRITICAL": "critical",
                "IMPORTANT": "important",
                "STANDARD": "standard"
            }
            f["severity"] = severity_map.get(risk_level, "standard")
    return risk_findings


def load_findings_fresh(contract_id: int) -> List[Dict]:
    """Run fresh analysis and extract findings."""
    result = api_run_analysis(contract_id)
    if "error" in result:
        st.session_state["rdl_error"] = result.get("error", "Analysis failed")
        return []
    analysis = result.get("analysis", result)
    findings = flatten_findings(analysis)
    
    # Enrich findings with clause text from database
    import sqlite3
    backend_path = Path(__file__).parent.parent.parent / "backend"
    db_path = str(backend_path.parent / "data" / "contracts.db")
    conn = sqlite3.connect(db_path)
    cursor = conn.cursor()
    
    for finding in findings:
        section = finding.get('section_number')
        if section and not finding.get('clause_text'):
            cursor.execute(
                "SELECT text FROM clauses WHERE contract_id = ? AND section_number = ?",
                (contract_id, str(section))
            )
            row = cursor.fetchone()
            if row:
                finding['clause_text'] = row[0]
            if not finding.get('redline_suggestion'):
                finding['redline_suggestion'] = finding.get('recommendation', '')
    
    conn.close()
    return findings


# ============================================================================
# STATE MANAGEMENT FUNCTIONS
# ============================================================================

def get_current_finding() -> Optional[Dict]:
    """Return finding at current index."""
    findings = st.session_state.get("rdl_findings", [])
    index = st.session_state.get("rdl_current_index", 0)
    if findings and 0 <= index < len(findings):
        return findings[index]
    return None


def get_decision(index: int) -> Dict:
    """Return decision dict for index, or empty defaults."""
    decisions = st.session_state.get("rdl_decisions", {})
    return decisions.get(index, {"decision": None, "modified_text": "", "note": ""})


def set_decision(index: int, decision: str, modified_text: str = "", note: str = ""):
    """Save decision to session state."""
    if "rdl_decisions" not in st.session_state:
        st.session_state["rdl_decisions"] = {}
    st.session_state["rdl_decisions"][index] = {
        "decision": decision,
        "modified_text": modified_text,
        "note": note
    }


def get_progress_stats() -> Dict:
    """Return {total, accepted, rejected, modified, pending}."""
    findings = st.session_state.get("rdl_findings", [])
    decisions = st.session_state.get("rdl_decisions", {})
    total = len(findings)
    accepted = sum(1 for d in decisions.values() if d.get("decision") == "accepted")
    rejected = sum(1 for d in decisions.values() if d.get("decision") == "rejected")
    modified = sum(1 for d in decisions.values() if d.get("decision") == "modified")
    pending = total - accepted - rejected - modified
    return {
        "total": total,
        "accepted": accepted,
        "rejected": rejected,
        "modified": modified,
        "pending": pending
    }


def go_next():
    """Increment index (stop at end)."""
    findings = st.session_state.get("rdl_findings", [])
    index = st.session_state.get("rdl_current_index", 0)
    if index < len(findings) - 1:
        st.session_state["rdl_current_index"] = index + 1


def go_previous():
    """Decrement index (stop at 0)."""
    index = st.session_state.get("rdl_current_index", 0)
    if index > 0:
        st.session_state["rdl_current_index"] = index - 1


def go_to_index(index: int):
    """Jump to specific index."""
    findings = st.session_state.get("rdl_findings", [])
    if 0 <= index < len(findings):
        st.session_state["rdl_current_index"] = index


# ============================================================================
# FORMATTING FUNCTIONS
# ============================================================================

def format_redline(text: str) -> str:
    """Convert ~~del~~ to red strikethrough, `add` to green bold."""
    if not text:
        return ""
    # Handle deletions: ~~deleted text~~
    text = re.sub(
        r'~~(.+?)~~',
        r'<span style="color:#EF4444;text-decoration:line-through;background:rgba(239,68,68,0.1);padding:0 2px;">\1</span>',
        text
    )
    # Handle additions: `added text`
    text = re.sub(
        r'`([^`]+)`',
        r'<span style="color:#22C55E;font-weight:600;background:rgba(34,197,94,0.15);padding:0 4px;border-radius:2px;">\1</span>',
        text
    )
    return text


def clean_redline_for_edit(text: str) -> str:
    """Remove redline markers for editing, keeping the suggested changes."""
    if not text:
        return ""
    # Remove deletion markers and their content (keep only additions)
    text = re.sub(r'~~.+?~~\s*', '', text)
    # Remove backticks but keep the content
    text = re.sub(r'`([^`]+)`', r'\1', text)
    return text.strip()


# ============================================================================
# RENDER FUNCTIONS
# ============================================================================

def render_contract_selector():
    """Render dropdown + load buttons with workflow gate checks."""
    contracts = api_get_contracts()

    col1, col2, col3 = st.columns([2, 1, 1])

    with col1:
        options = ["Select a contract..."] + [
            f"{c.get('id', 0)}: {(c.get('title') or 'Untitled')[:50]}"
            for c in contracts
        ]
        selected = st.selectbox(
            "Contract",
            options,
            key="rdl_contract_select",
            label_visibility="collapsed"
        )
        if selected != "Select a contract...":
            contract_id = int(selected.split(":")[0])
            st.session_state["rdl_contract_id"] = contract_id
            st.session_state["rdl_contract_title"] = selected.split(": ", 1)[1] if ": " in selected else ""

    # Check workflow gate for selected contract
    contract_id = st.session_state.get("rdl_contract_id")
    can_proceed = True
    gate_message = ""
    if contract_id:
        can_proceed, gate_message = check_workflow_gate(contract_id)

    with col2:
        risk_findings_available = bool(st.session_state.get("risk_findings", []))
        btn_disabled = not risk_findings_available or not can_proceed
        if st.button(
            "Load from Analysis",
            key="rdl_load_analysis",
            disabled=btn_disabled,
            use_container_width=True
        ):
            findings = load_findings_from_risk_analysis()
            if findings:
                st.session_state["rdl_findings"] = findings
                st.session_state["rdl_current_index"] = 0
                st.session_state["rdl_decisions"] = {}
                st.session_state["rdl_source"] = "analysis"
                st.session_state["rdl_error"] = None
                st.rerun()

    with col3:
        contract_selected = contract_id is not None
        btn_disabled = not contract_selected or not can_proceed
        if st.button(
            "Run Fresh Scan",
            key="rdl_fresh_scan",
            disabled=btn_disabled,
            type="primary",
            use_container_width=True
        ):
            st.session_state["rdl_loading"] = True
            with st.spinner("Running analysis..."):
                findings = load_findings_fresh(contract_id)
            st.session_state["rdl_loading"] = False
            if findings:
                st.session_state["rdl_findings"] = findings
                st.session_state["rdl_current_index"] = 0
                st.session_state["rdl_decisions"] = {}
                st.session_state["rdl_source"] = "fresh"
                st.session_state["rdl_error"] = None
            st.rerun()

    # Show gate warning if blocked
    if contract_id and not can_proceed:
        st.warning(f"ðŸ”’ {gate_message}")

    # Show error if any
    if st.session_state.get("rdl_error"):
        st.error(st.session_state["rdl_error"])


def render_finding_header(finding: Dict, index: int, total: int):
    """Render: Finding X of Y | section | severity badge | category | issue"""
    severity = finding.get("severity", "standard").lower()
    cfg = SEVERITY_CONFIG.get(severity, SEVERITY_CONFIG["standard"])

    section_num = finding.get("section_number", "")
    section_title = finding.get("section_title", finding.get("clause_title", ""))
    category = finding.get("category", "").title()
    issue = finding.get("finding", finding.get("issue", ""))[:100]

    # Current decision indicator
    decision = get_decision(index)
    decision_text = ""
    if decision["decision"] == "accepted":
        decision_text = " - Accepted"
    elif decision["decision"] == "rejected":
        decision_text = " - Rejected"
    elif decision["decision"] == "modified":
        decision_text = " - Modified"

    # Header row with title and severity
    col_title, col_badge = st.columns([4, 1])
    with col_title:
        title_parts = [f"**Finding {index + 1} of {total}**"]
        if section_num:
            title_parts.append(f"Section {section_num}")
        if section_title:
            title_parts.append(section_title)
        if decision_text:
            title_parts.append(decision_text)
        st.markdown(" | ".join(title_parts))

    with col_badge:
        if severity == "dealbreaker":
            st.error(f"{cfg['icon']} {cfg['label']}")
        elif severity == "critical":
            st.warning(f"{cfg['icon']} {cfg['label']}")
        elif severity == "important":
            st.info(f"{cfg['icon']} {cfg['label']}")
        else:
            st.success(f"{cfg['icon']} {cfg['label']}")

    # Category and issue
    details = []
    if category:
        details.append(f"**Category:** {category}")
    details.append(f"**Issue:** {issue}{'...' if len(finding.get('finding', '')) > 100 else ''}")
    st.caption(" | ".join(details))


def render_original_pane(finding: Dict):
    """Render left column with section # and original clause text."""
    clause_text = finding.get("clause_text", "")
    section = finding.get("clause_reference", "") or finding.get("section", "") or ""

    if section:
        st.markdown(f"**{section}**")
    else:
        st.markdown("**ORIGINAL**")

    if clause_text:
        st.text_area(
            "Original",
            value=clause_text,
            height=300,
            disabled=True,
            key="rdl_original_text",
            label_visibility="collapsed"
        )
    else:
        st.info("No original clause text available")


def format_redline_html(text: str) -> str:
    """Convert redline delimiters to styled HTML.

    - ~~text~~ becomes strikethrough (red, deleted)
    - `text` becomes highlighted (green, added)
    """
    # Escape HTML entities first
    text = text.replace("&", "&amp;").replace("<", "&lt;").replace(">", "&gt;")

    # Convert ~~strikethrough~~ to red deletion styling
    text = re.sub(
        r'~~(.+?)~~',
        r'<span style="text-decoration: line-through; color: #ff6b6b; background-color: rgba(239,68,68,0.1); padding: 1px 3px;"></span>',
        text,
        flags=re.DOTALL
    )

    # Convert `backticks` to green addition styling
    text = re.sub(
        r'`(.+?)`',
        r'<span style="background-color: #2d5a3d; color: #90EE90; padding: 2px 4px; border-radius: 3px;"></span>',
        text,
        flags=re.DOTALL
    )

    # Convert newlines to <br> for HTML display
    text = text.replace("\n", "<br>")


    return text


def render_revision_pane(finding: Dict):
    """Render right column with formatted redline_suggestion."""
    redline = finding.get("redline_suggestion", "")

    # Check if there's a modified version
    index = st.session_state.get("rdl_current_index", 0)
    decision = get_decision(index)
    if decision["decision"] == "modified" and decision.get("modified_text"):
        display_text = decision["modified_text"]
        label = "**MODIFIED REVISION**"
    else:
        display_text = redline
        label = "**SUGGESTED REDLINE**"

    st.markdown(label)
    if display_text:
        # Render styled HTML with proper formatting
        styled_html = format_redline_html(display_text)
        html_container = f"""
        <div style="
            background-color: rgba(30, 41, 59, 0.4);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 6px;
            padding: 12px;
            min-height: 180px;
            max-height: 300px;
            overflow-y: auto;
            font-family: monospace;
            font-size: 14px;
            line-height: 1.6;
            color: #E2E8F0;
        ">{styled_html}</div>
        """
        st.markdown(html_container, unsafe_allow_html=True)
        st.caption("Legend: strikethrough = delete | highlighted = add")
    else:
        st.info("No revision suggestion available")


def render_footer(finding: Dict):
    """Render business impact, cascade_impacts, confidence."""
    issue = finding.get("finding", finding.get("issue", ""))
    recommendation = finding.get("recommendation", "")
    cascades = finding.get("cascade_impacts", [])
    confidence = finding.get("confidence", 0)
    confidence_pct = int(confidence * 100) if isinstance(confidence, float) and confidence <= 1 else int(confidence)

    st.divider()

    col_info, col_conf = st.columns([4, 1])

    with col_info:
        st.markdown(f"**Business Impact:** {issue}")
        if recommendation:
            st.markdown(f"**Recommendation:** {recommendation}")
        if cascades:
            cascade_items = ", ".join(cascades[:3])
            if len(cascades) > 3:
                cascade_items += f" (+{len(cascades) - 3} more)"
            st.caption(f"Cascade Impacts: {cascade_items}")

    with col_conf:
        st.metric("Confidence", f"{confidence_pct}%")


def render_actions(index: int):
    """Render Reject/Modify/Accept buttons. Update decisions on click."""
    decision = get_decision(index)
    current = decision.get("decision")

    col1, col2, col3 = st.columns(3)

    with col1:
        btn_type = "primary" if current == "rejected" else "secondary"
        if st.button("Reject", key=f"rdl_reject_{index}", use_container_width=True, type=btn_type):
            set_decision(index, "rejected")
            go_next()
            st.rerun()

    with col2:
        btn_type = "primary" if current == "modified" else "secondary"
        if st.button("Modify", key=f"rdl_modify_{index}", use_container_width=True, type=btn_type):
            st.session_state["rdl_show_modify_modal"] = True
            st.rerun()

    with col3:
        btn_type = "primary" if current == "accepted" else "secondary"
        if st.button("Accept", key=f"rdl_accept_{index}", use_container_width=True, type=btn_type):
            set_decision(index, "accepted")
            go_next()
            st.rerun()


def render_navigation(index: int, total: int):
    """Render Prev/Next buttons, dot indicators, Jump dropdown."""
    st.divider()

    col1, col2, col3, col4 = st.columns([1, 3, 1, 1])

    with col1:
        if st.button("Prev", key="rdl_prev", disabled=(index == 0), use_container_width=True):
            go_previous()
            st.rerun()

    with col2:
        # Text-based progress indicator
        indicators = []
        for i in range(total):
            decision = get_decision(i)
            if decision.get("decision") == "accepted":
                mark = "A"
            elif decision.get("decision") == "rejected":
                mark = "X"
            elif decision.get("decision") == "modified":
                mark = "M"
            else:
                mark = "o"

            if i == index:
                indicators.append(f"[{mark}]")
            else:
                indicators.append(mark)

        st.markdown(f"**Progress:** {' '.join(indicators)}")
        st.caption("A=Accepted, X=Rejected, M=Modified, o=Pending, []=Current")

    with col3:
        if st.button("Next", key="rdl_next", disabled=(index >= total - 1), use_container_width=True):
            go_next()
            st.rerun()

    with col4:
        jump_options = [f"#{i+1}" for i in range(total)]
        selected_jump = st.selectbox(
            "Jump",
            jump_options,
            index=index,
            key="rdl_jump",
            label_visibility="collapsed"
        )
        new_index = int(selected_jump.replace("#", "")) - 1
        if new_index != index:
            go_to_index(new_index)
            st.rerun()


def render_progress_bar():
    """Render stats + Export + Report buttons."""
    stats = get_progress_stats()

    st.divider()

    col_a, col_r, col_m, col_p, col_export, col_report = st.columns([1, 1, 1, 1, 1, 1])

    with col_a:
        st.metric("Accepted", stats['accepted'])
    with col_r:
        st.metric("Rejected", stats['rejected'])
    with col_m:
        st.metric("Modified", stats['modified'])
    with col_p:
        st.metric("Pending", stats['pending'])
    with col_export:
        export_data = export_decisions()
        st.download_button(
            label="Export JSON",
            data=export_data,
            file_name=f"redline_decisions_{datetime.now().strftime('%Y%m%d_%H%M%S')}.json",
            mime="application/json",
            key="rdl_download",
            use_container_width=True
        )
    with col_report:
        contract_id = st.session_state.get("rdl_contract_id")
        if st.button("ðŸ“Š Generate Report", key="rdl_generate_report", use_container_width=True, disabled=not contract_id):
            if contract_id:
                with st.spinner("Generating deterministic report..."):
                    report, report_id = generate_redline_report(contract_id)
                    st.session_state["rdl_report"] = report
                    st.session_state["rdl_report_id"] = report_id
                st.rerun()

    # Check if review is complete
    pending_count = stats.get("pending", 0)
    total_count = stats.get("total", 0)

    if total_count > 0 and pending_count == 0:
        st.success("**Review Complete!** All findings have been reviewed.")
        st.markdown("**Next Steps:**")
        st.markdown("1. **Save & Complete** - Persist decisions to database")
        st.markdown("2. **Export JSON** - Download decisions for documentation")

        col_save, col_back, col_spacer = st.columns([1, 1, 2])
        with col_save:
            if st.button("Save & Complete", key="rdl_save_complete", type="primary"):
                # Collect decisions
                decisions = st.session_state.get("rdl_decisions", {})
                findings = st.session_state.get("rdl_findings", [])
                contract_id = st.session_state.get("rdl_contract_id")
                risk_before = st.session_state.get("rdl_overall_risk", "")

                # Format decisions for API
                decision_list = []
                for idx, dec in decisions.items():
                    finding = findings[idx] if idx < len(findings) else {}
                    decision_list.append({
                        'clause_index': idx,
                        'decision': dec.get('decision'),
                        'modified_text': dec.get('modified_text', ''),
                        'note': dec.get('note', ''),
                        'section': finding.get('section_number', ''),
                        'category': finding.get('category', '')
                    })

                result = api_save_redline(contract_id, decision_list, risk_before)
                if 'error' in result:
                    st.error(f"Save failed: {result['error']}")
                else:
                    st.success(f"Saved! Redline ID: {result.get('redline_id')}")

                    # Advance workflow to unlock compare stage
                    if advance_workflow_after_approval(contract_id):
                        st.success("âœ… Workflow advanced: Compare stage unlocked")

                    st.session_state["rdl_saved"] = True
                    st.rerun()
        
        with col_back:
            if st.button("Back to Portfolio", key="rdl_back_portfolio"):
                st.switch_page("pages/2_Contracts_Portfolio.py")


def render_modify_editor(finding: Dict, index: int):
    """Render text_area with clean version of redline, note field, Save/Cancel."""
    st.markdown("---")
    st.markdown("### Modify Revision")

    redline = finding.get("redline_suggestion", "")
    clean_text = clean_redline_for_edit(redline)

    decision = get_decision(index)
    initial_text = decision.get("modified_text") or clean_text
    initial_note = decision.get("note", "")

    modified_text = st.text_area(
        "Edit the suggested revision:",
        value=initial_text,
        height=150,
        key=f"rdl_modify_text_{index}"
    )

    note = st.text_input(
        "Note (optional):",
        value=initial_note,
        key=f"rdl_modify_note_{index}",
        placeholder="Reason for modification..."
    )

    col1, col2 = st.columns(2)

    with col1:
        if st.button("Save", key=f"rdl_save_modify_{index}", type="primary", use_container_width=True):
            set_decision(index, "modified", modified_text, note)
            st.session_state["rdl_show_modify_modal"] = False
            go_next()
            st.rerun()

    with col2:
        if st.button("Cancel", key=f"rdl_cancel_modify_{index}", use_container_width=True):
            st.session_state["rdl_show_modify_modal"] = False
            st.rerun()


def export_decisions() -> str:
    """Generate JSON export of all decisions."""
    findings = st.session_state.get("rdl_findings", [])
    decisions = st.session_state.get("rdl_decisions", {})

    export_data = {
        "contract_id": st.session_state.get("rdl_contract_id"),
        "contract_title": st.session_state.get("rdl_contract_title"),
        "source": st.session_state.get("rdl_source"),
        "exported_at": datetime.now().isoformat(),
        "summary": get_progress_stats(),
        "items": []
    }

    for i, finding in enumerate(findings):
        decision = decisions.get(i, {"decision": None, "modified_text": "", "note": ""})
        export_data["items"].append({
            "index": i,
            "section_number": finding.get("section_number", ""),
            "section_title": finding.get("section_title", ""),
            "severity": finding.get("severity", ""),
            "category": finding.get("category", ""),
            "finding": finding.get("finding", ""),
            "original_clause": finding.get("clause_text", ""),
            "suggested_revision": finding.get("redline_suggestion", ""),
            "decision": decision.get("decision"),
            "modified_text": decision.get("modified_text", ""),
            "note": decision.get("note", "")
        })

    return json.dumps(export_data, indent=2)


def render_empty_state():
    """Render empty state when no findings loaded."""
    st.info("No findings loaded. Select a contract and load findings to begin review.")


# ============================================================================
# MAIN PAGE
# ============================================================================

init_page("Redline Reviews", "ðŸ“", max_width=1400)

page_header(
    "Redline Reviews",
    subtitle="Review and approve AI-suggested contract revisions with CCE-Plus deterministic reports",
    show_status=True,
    show_version=True
)

init_redline_state()

with content_container():
    # Contract selector row
    render_contract_selector()

    findings = st.session_state.get("rdl_findings", [])

    if not findings:
        render_empty_state()
    else:
        index = st.session_state.get("rdl_current_index", 0)
        total = len(findings)

        # Clamp index to valid range
        if index >= total:
            index = total - 1
            st.session_state["rdl_current_index"] = index

        finding = findings[index] if index < total else None

        if finding:
            # Navigation at top for context
            render_navigation(index, total)

            st.markdown("---")

            # Two columns only: Original | Revision
            col_left, col_right = st.columns(2)
            with col_left:
                render_original_pane(finding)
            with col_right:
                render_revision_pane(finding)

            # Actions below panes
            render_actions(index)

            # Modification editor (if in modify mode)
            if st.session_state.get("rdl_modify_mode"):
                render_modify_editor(finding, index)

            # Progress bar with Save button
            render_progress_bar()

            # Display generated report if available
            if st.session_state.get("rdl_report"):
                st.markdown("---")
                st.markdown("### ðŸ“Š Generated Redline Report")
                report_id = st.session_state.get("rdl_report_id", "N/A")
                st.caption(f"Report ID: {report_id} (reproducible)")

                with st.expander("View Report", expanded=True):
                    report_content = st.session_state.get("rdl_report", "")
                    st.markdown(report_content)

                    # Download button for report
                    st.download_button(
                        label="Download Report (Markdown)",
                        data=report_content,
                        file_name=f"redline_report_{report_id}.md",
                        mime="text/markdown",
                        key="rdl_download_report",
                        use_container_width=True
                    )
